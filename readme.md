### Решение тестовых вопросов
1.1. **Что такое goroutine в Go и как она отличается от традиционного потока?**

Goroutine — это лёгкая единица выполнения в языке Go, которая позволяет выполнять функции параллельно. В отличие от традиционных потоков (threads), goroutines гораздо легче и потребляют меньше ресурсов, так как они управляются рантаймом Go и могут использоваться в большом количестве (десятки тысяч и больше) без значительных затрат на создание или переключение контекста.

Основные отличия goroutines от традиционных потоков:
- **Меньший объем памяти**: Goroutines создаются с небольшим стеком (обычно несколько килобайт), который автоматически расширяется по мере необходимости.
- **Сопланарное планирование**: Goroutines управляются Go runtime, который использует M:N планирование, то есть большое количество goroutines может выполняться на ограниченном количестве потоков ОС.
- **Простота использования**: Для запуска goroutine достаточно перед вызовом функции указать ключевое слово `go`, в то время как создание и управление потоками в других языках требует более сложного кода.

---

1.2. **Что такое каналы в Go? Что будет возвращено при чтении из закрытого канала?**

Каналы в Go — это средство для синхронизации и передачи данных между goroutines. Они обеспечивают безопасную передачу данных, не требуя явных механизмов блокировок, и позволяют одной goroutine отправлять данные другой через канал.

Чтение из закрытого канала:
- Если в канале еще есть данные, то при чтении вернется очередное значение.
- Если канал закрыт и все данные прочитаны, при попытке чтения будет возвращено **нулевое значение** для типа данных, передаваемого через канал, и **логическое значение** `false`, которое указывает, что канал закрыт.

Пример:
```go
val, ok := <-channel
if !ok {
    // канал закрыт
}
```

---

1.3. **Как в Go реализовать взаимное исключение при доступе к общим ресурсам?**

В Go взаимное исключение при доступе к общим ресурсам обычно реализуется с помощью структуры `sync.Mutex`, которая представляет собой мьютекс (mutual exclusion). Мьютексы позволяют заблокировать доступ к общим ресурсам, пока они не будут освобождены другой goroutine.

Пример использования `sync.Mutex`:
```go
var mu sync.Mutex
var sharedResource int

func safeIncrement() {
    mu.Lock()   // блокировка мьютекса
    sharedResource++
    mu.Unlock() // разблокировка мьютекса
}
```
Кроме мьютексов, в Go также можно использовать каналы для координации доступа к общим данным.

---

1.4. **Что такое анонимная функция в Go?**

Анонимная функция — это функция, которая не имеет имени. Такие функции можно объявить и выполнить непосредственно в месте их создания. Они могут быть присвоены переменной или переданы в качестве аргумента другой функции.

Пример анонимной функции:
```go
func() {
    fmt.Println("Это анонимная функция")
}()
```
Анонимные функции могут захватывать и использовать переменные из внешней области видимости (замыкания):
```go
x := 5
increment := func() int {
    x++
    return x
}
fmt.Println(increment()) // 6
```

---

1.5. **Как в Go обрабатывать паники и ошибки?**

В Go есть два основных механизма обработки ошибок и сбоев:
- **Ошибки (errors)**: В Go ошибки являются обычными значениями, которые возвращаются из функций. Программисты должны явно проверять наличие ошибок и обрабатывать их. В стандартной библиотеке есть интерфейс `error`, который может использоваться для создания и обработки ошибок.
  
  Пример:
  ```go
  func someFunc() error {
      if someCondition {
          return errors.New("произошла ошибка")
      }
      return nil
  }
  
  err := someFunc()
  if err != nil {
      fmt.Println(err)
  }
  ```

- **Паники (panic) и отложенные вызовы (defer)**: Паники используются для критических ошибок, от которых программа не может восстановиться. Паника приводит к немедленному прекращению выполнения программы, но перед завершением можно перехватить панику с помощью `recover()` внутри отложенной функции (`defer`).

  Пример:
  ```go
  func mayPanic() {
      defer func() {
          if r := recover(); r != nil {
              fmt.Println("Восстановление после паники:", r)
          }
      }()
      panic("произошла паника")
  }
  ```

---

1.6. **Существует ли концепция наследования в Go?**

В Go нет традиционной концепции классов и наследования, как в других ООП-языках (например, в C++ или Java). Однако Go использует композицию для повторного использования кода. Вместо наследования, структуры в Go могут содержать другие структуры, что позволяет "встраивать" (embedding) функциональность.

Пример композиции:
```go
type Base struct {
    name string
}

type Derived struct {
    Base
    age int
}

d := Derived{Base: Base{name: "John"}, age: 30}
fmt.Println(d.name) // доступ к полю "name" из встроенной структуры
```

---

1.7. **Что такое интерфейсы в Go?**

Интерфейсы в Go — это абстракции, которые определяют поведение через набор методов. Любая структура, которая реализует методы интерфейса, автоматически считается реализацией этого интерфейса, без явного указания. Интерфейсы позволяют использовать полиморфизм и писать более гибкий код.

Пример интерфейса:
```go
type Speaker interface {
    Speak() string
}

type Human struct {}

func (h Human) Speak() string {
    return "Hello!"
}

func saySomething(s Speaker) {
    fmt.Println(s.Speak())
}

saySomething(Human{})
```

---

1.8. **Что такое "грязное чтение" (dirty read) в контексте баз данных?**

"Грязное чтение" (dirty read) — это ситуация, когда одна транзакция читает данные, которые были изменены другой транзакцией, но ещё не были зафиксированы (committed). Это может привести к недостоверным данным, если другая транзакция будет отменена (rollback), так как изменения, которые читала первая транзакция, могут быть откатаны.

Пример:
- Транзакция A обновляет запись.
- Транзакция B читает обновленное значение.
- Транзакция A выполняет откат, и данные возвращаются в исходное состояние.
В результате Транзакция B имеет "грязные" данные, которые фактически никогда не существовали в базе данных.

Для предотвращения грязного чтения используются более строгие уровни изоляции транзакций, такие как **Repeatable Read** или **Serializable**.


### Описание работы программы

Программа на языке Go выполняет следующие действия:

1. **Чтение данных**: 
   - Программа может читать данные как из файла, так и из стандартного ввода (stdin). Источник данных указывается через аргумент командной строки.
   - Данные должны быть представлены в виде JSON массива чисел (например, `[1, 2, 3, 4, 5]`).
   
2. **Суммирование чисел**:
   - Программа подсчитывает сумму всех чисел, содержащихся в JSON массиве.

3. **HTTP-запрос**:
   - Программа выполняет HTTP GET запрос на заданный URL (он может быть передан через файл конфигурации или переменную окружения).
   - Проверяется, что код ответа от сервера равен 200 (HTTP OK).

4. **Логирование**:
   - Программа логирует результаты каждого этапа в лог-файл. Логи включают в себя:
     - Данные о том, откуда были прочитаны числа (из файла или stdin),
     - Сумму чисел,
     - URL и статус ответа на HTTP запрос,
     - В случае ошибки, текст ошибки.

### Структура JSON

Программа ожидает JSON файл или ввод, содержащий **массив чисел**. Пример:

```json
[1, 2, 3, 4, 5]
```

Это может быть простой файл с массивом целых чисел. Пример файла `numbers.json`:

```json
[10, 20, 30, 40, 50]
```

### Инструкция по запуску программы

1. **Подготовка к запуску**:
   - Убедитесь, что у вас установлен Go (версия 1.16 или новее).
   - Склонируйте репозиторий с программой на вашу машину:
     ```bash
     git clone <https://github.com/SafetyDuck5676/SibentekTrainee>
     cd <SibentekTrainee>
     ```

2. **Аргументы командной строки**:

   Программа принимает следующие аргументы командной строки:

   - `-source`: определяет источник данных. Возможные значения:
     - `stdin` — для чтения из стандартного ввода.
     - Путь к файлу — для чтения данных из указанного файла.
   - `-output`: путь к файлу для записи результатов.

   Пример использования программы:

   - Для чтения чисел из файла:
     ```bash
     go run main.go -source numbers.json -output result.log
     ```

   - Для чтения чисел из стандартного ввода:
     ```bash
     echo '[1, 2, 3, 4, 5]' | go run main.go -source stdin -output result.log
     ```

3. **Файл конфигурации или переменные окружения**:
   
   Программа поддерживает конфигурацию через **переменные окружения**. Для задания URL, на который будет отправлен HTTP запрос, нужно установить переменную окружения `API_URL`.

   Пример для Linux/MacOS:
   ```bash
   export API_URL="https://example.com/api"
   ```

   Пример для Windows:
   ```bash
   set API_URL="https://example.com/api"
   ```

   Или можно создать файл конфигурации, например `config.env`, и загрузить его перед запуском программы:
   ```bash
   export $(cat config.env | xargs)
   ```

4. **Запуск с выводом результата в лог**:
   - Результаты выполнения программы будут записаны в файл, указанный через флаг `-output`.
   - Пример:
     ```bash
     go run main.go -source numbers.json -output result.log
     ```

5. **Пример логов**:
   Пример записи в лог-файл `result.log`:
   ```
   2024/10/01 10:30:00 Чтение данных из файла: numbers.json
   2024/10/01 10:30:00 Сумма чисел: 150
   2024/10/01 10:30:00 Выполнение HTTP GET запроса на https://example.com/api
   2024/10/01 10:30:00 Статус ответа: 200
   ```

6. **Тестирование программы**:
   Для тестирования программы запустите юнит-тесты:
   ```bash
   go test -v
   ```

   Программа включает юнит-тесты для основных функций: чтение данных, суммирование чисел, выполнение HTTP запросов и логирование.
